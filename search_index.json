[
["index.html", "EigenGWAS theory and application Chapter 1 EigenGWAS basis 1.1 Genetic relatedness matrix \\(\\mathbf{G}\\) 1.2 EigenGWAS analysis 1.3 Connection to SVD 1.4 Intepretation", " EigenGWAS theory and application Guo-Bo Chen [chen.guobo@foxmail.com] 2018-11-27 Chapter 1 EigenGWAS basis This project is dedicated to EigenGWAS, a linear model analysis approach for eigenvectors on genomic data, which can be represented as \\(\\mathbf{X}\\) the \\(n \\times m\\) genotype matrix. Without loss of generality, \\(x_j\\) for the \\(i^{th}\\) locus is a biallic locus. The data matrix \\(\\mathbf{X}\\) can be generated from genotyping chips, NGS, or GBS. set.seed(2018) freq=runif(1000, 0.1, 0.9) X=matrix(0, 100, length(freq)) for(i in 1:length(freq)) { X[,i]=rbinom(nrow(X), 2, freq[i]) } print(dim(X)) ## [1] 100 1000 plot(freq, colMeans(X)/2, xlab=&quot;Simulated frequency&quot;, ylab=&quot;Estimated frequency&quot;, bty=&#39;n&#39;, pch=16, cex=0.5) abline(a=0, b=1, col=&quot;red&quot;, lty=2) 1.1 Genetic relatedness matrix \\(\\mathbf{G}\\) We can construct the \\(n\\times\\) genetic relatedness matrix as \\(\\mathbf{X}\\) the \\(n\\times m\\) genotype matrix. We can construct the \\(n\\times\\) genetic relatedness matrix as \\[\\mathbf{G}=\\tilde{\\mathbf{X}}\\tilde{\\mathbf{X}}^T\\] in which \\(\\tilde{\\mathbf{X}}\\) is the scaled form of \\(\\mathbf{X}\\) However, upon the mating type of the species, \\(\\mathbf{G}\\) should be constructly differently. For a random mating population, \\(x_l\\) is scaled as \\(\\tilde{x}_l=\\frac{x_l-2p_l}{\\sqrt{2p_lq_l}}\\), whereas for inbred population, \\(\\tilde{x}_l=\\frac{x_l-2p_l}{\\sqrt{4p_lq_l}}\\). \\(q_l\\) equals \\(1-p_l\\). So for a pair of individuals \\(i\\) and \\(j\\), \\[G_{ij}=\\frac{1}{\\tilde{m}}\\sum_l^{\\tilde{m}}\\frac{(x_{il}-2p_l)(x_{jl}-2p_l)}{2(1+F)p_iq_i}\\] in which \\(\\tilde{m}\\) is the number of genotyped loci at both individal \\(i\\) and \\(j\\), and \\(F\\) the inbreeding coefficient takes value of 0 for random mating population and 1 for inbred population. 1.1.1 Statistical properties of \\(\\mathbf{G}\\) Given \\(\\mathbf{G}\\), we can define two population parameters, \\(n_e\\), the effective population size, and \\(m_e\\), the effective number of markers. Let \\(\\mathbf{G}_o\\) denote the off diagonal elements of \\(\\mathbf{G}\\), then we have \\[n_e=\\frac{-1}{mean(\\mathbf{G}_o)}\\] \\(n_e\\) reflects true relatedness between any pair of samples; \\[m_e=\\frac{1}{Var(\\mathbf{G}_o)}\\] The ratio between \\(\\frac{m_e}{m}\\) reflects general linkage disequilibrium between the markers. Alternatively, \\(m_e\\) can be written as \\[m_e=\\frac{\\sum_{i=1}^m\\sum_{j=1}^m\\rho_{ij}}{m^2}\\] Xs=apply(X, 2, scale) G=Xs %*% t(Xs)/ncol(X) Ne=-1/mean(G[col(G)&lt;row(G)]) Me=1/var(G[col(G)&lt;row(G)]) print(paste(&quot;Ne=&quot;, Ne, &quot;Me=&quot;, Me, &quot;given N=&quot;, nrow(Xs), &quot;and M=&quot;, ncol(Xs))) ## [1] &quot;Ne= 100 Me= 1080.91076380488 given N= 100 and M= 1000&quot; hist(G[col(G)&lt;row(G)], main=&quot;GRM&quot;, xlab=&quot;Relatedness&quot;, breaks = 25) legend(&quot;topright&quot;, legend = c(paste0(&quot;Ne=&quot;, format(Ne, digits = 2)), paste0(&quot;Me=&quot;, format(Me, digits = 2)) ), bty = &#39;n&#39;) 1.2 EigenGWAS analysis Given eigenanalysis of \\(\\mathbf{X}\\), we have \\(\\mathbf{E\\Lambda E}\\), in which \\(\\mathbf{\\Lambda}\\) is the diagonal matrix for eigenvalues and \\(\\mathbf{E}_k\\) is the eigenvector associated with the \\(k^{th}\\) largest eigenvalue, and regress \\(\\mathbf{E}_k\\), the \\(k^{th}\\) column, on each marker, we have the model below \\[\\mathbf{E}_k=a+\\beta_j\\mathbf{x}_i+e\\] It consequently generates \\(m\\) estimates of \\(\\beta\\), \\(\\sigma_j\\), and their corresponding \\(p\\) values. Given the \\(m\\) \\(p\\) values, the conventional Manhattan plot can be made. In particular, the one-degree-of-freedom \\(\\chi^2_1\\) has approximation as \\[4\\frac{\\color{red}{n_1}\\color{blue}{n_2}}{n}\\frac{(\\color{red}{p_{1,l}}-\\color{blue}{p_{2,l}})^2}{\\bar{p}_l\\bar{q}_l}\\]. \\(\\color{red}{n_1}\\) and \\(\\color{blue}{n_2}\\) are the numbers of samples at the left and right side of “0” on the eigenvector, see the figure below. \\(\\color{red}{p_{1,l}}\\) and \\(\\color{blue}{p_{2,l}}\\) are frequencies of the reference allele in two subgroups, respectively. \\(\\bar{p_l}\\) is the allele frequency of the reference allele. eigenG=eigen(G) layout(matrix(1:2, 1, 2)) barplot(eigenG$values, main=&quot;Eigenvalues&quot;) plot(eigenG$vectors[,1], eigenG$vectors[,2], xlab=&quot;Eigen 1&quot;, ylab=&quot;Eigen 2&quot;, bty=&#39;n&#39;, main=&quot;Eigenspace&quot;, pch=16, cex=0.5, col=ifelse(eigenG$vectors[,1]&gt;0, &quot;red&quot;, &quot;blue&quot;)) abline(v=0, col=&quot;grey&quot;, lty=2) 1.2.1 Population structure \\(\\lambda_{GC}\\) We can define \\(\\lambda_{GC}=\\chi^2_{1,median(p)}/\\chi^2_{1,0.5}\\), in which \\(\\chi^2_{1,0.5}=0.455\\). We further use subscript \\(k\\) to denote \\(\\lambda_{GC_k}\\) the one that is estimated from \\(\\mathbf{E}_k\\). When the population structure is completely driven by genetic drift, \\(\\lambda_{GC_k} \\approx \\Lambda_k\\). After technical correction, correspondingly \\(\\tilde\\chi^2_1=\\chi^2_1/\\lambda_{GC}\\), a reduce of the test statistic compared to its original form. Chi=rchisq(10000, 1, ncp=0.2) layout(matrix(1:2, 1, 2)) qqplot(main=&quot;Raw&quot;, rchisq(1000,1), Chi, bty=&quot;n&quot;, xlab=expression(paste(&quot;Theoretical &quot;,chi[1]^2)), ylab=expression(paste(&quot;Observed &quot;,chi[1]^2)), pch=16, cex=0.5) abline(a=0, b=1, col=&quot;red&quot;, lty=2) gc=median(Chi)/qchisq(0.5, 1, lower.tail = F) ChiGC=Chi/gc qqplot(main=&quot;After correction&quot;, rchisq(1000,1), ChiGC, bty=&quot;n&quot;, xlab=expression(paste(&quot;Theoretical &quot;,chi[1]^2)), ylab=expression(paste(&quot;Observed &quot;,chi[1]^2)), pch=16, cex=0.5) abline(a=0, b=1, col=&quot;red&quot;, lty=2) 1.2.2 Threshold for EigenGWAS As shown above, EigenGWAS Bonferroni correction, such as \\(\\alpha/m\\), can be used to set the threshold at the significance level \\(\\alpha\\), such as \\(\\alpha=0.05\\). 1.3 Connection to SVD SVD of \\(\\mathbf{X}=\\mathbf{U\\Lambda V}\\), the EigenGWAS model can be written as \\(\\mathbf{V}_k=\\frac{\\mathbf{XU}_k}{\\Lambda_k}\\). However, in this transformation, eigenvalue is involved, as would be show. It will reduce the statistical power for EigenGWAS. 1.4 Intepretation The EigenGWAS model resembles the Newtown’s first and the second law for classical mechanics. The first law states that In an inertial frame of reference, an object either remains at rest or continues to move at a constant velocity, unless acted upon by a force. Analogously, in population genetics, it can be seemed as genetic drift that is constantly driving the a pair of population apart from each other, and its velocity can be quantified by a binomial distribution as \\(\\frac{pq}{\\tilde{n}_e}\\). In an inertial frame of reference, the vector sum of the forces \\(F\\) on an object is equal to the mass m of that object multiplied by the acceleration a of the object: \\(F = ma\\). Analogously, the selection can drive a genomic region run against its reference population at a velocity greater than \\(\\frac{pq}{\\tilde{n}_e}\\). "],
["protocol.html", "Chapter 2 Protocol 2.1 Protocols for selection 2.2 Protocol for predicted eigenvectors", " Chapter 2 Protocol 2.1 Protocols for selection Constructing genetic relationship matrix \\(\\mathbf{G}\\). The difference between a random mating population and inbred population is the way \\(\\mathbf{G}\\) is constructed. So for a pair of individuals \\(i\\) and \\(j\\), \\[G_{ij}=\\frac{1}{\\tilde{m}}\\sum_l^{\\tilde{m}}\\frac{(x_{il}-2p_l)(x_{jl}-2p_l)}{2(1+F)p_iq_i}\\] and \\(F=1\\) for inbred lines. Conducting eigenanalysis for \\(\\mathbf{G}\\). Linear regression analysis for each SNP. 2.1.1 Rscript pipeline for random mating population plink2=&#39;/Users/gc5k/bin/plink_mac/plink&#39; dat=&quot;./data/euro/euro&quot; #make-grm grmCmd=paste(plink2, &quot;--bfile &quot;, dat, &quot;--make-grm-gz --out &quot;, dat) system(grmCmd) gz=gzfile(paste0(dat, &quot;.grm.gz&quot;)) grm=read.table(gz, as.is = T) Ne=-1/mean(grm[grm[,1]!=grm[,2], 4]) Me=1/var(grm[grm[,1]!=grm[,2], 4]) print(paste(&quot;Ne=&quot;, format(Ne, digits = 2), &quot;Me=&quot;, format(Me, digits = 2))) ## [1] &quot;Ne= 199 Me= 21870&quot; #pca pcaCmd=paste(plink2, &quot;--bfile &quot;, dat, &quot;--pca 5 --out &quot;, dat) system(pcaCmd) barplot(read.table(paste0(dat, &quot;.eigenval&quot;), as.is = T)[,1]/2, border = F) pc=read.table(paste0(dat, &quot;.eigenvec&quot;), as.is = T) plot(pc[,3], pc[,4], xlab=&quot;Eigenvector 1&quot;, ylab=&quot;Eigenvector 2&quot;, bty=&quot;n&quot;, main=&quot;Eigenspace&quot;, bty=&quot;n&quot;, col=ifelse(pc[,3]&gt;0, &quot;red&quot;, &quot;blue&quot;), pch=16, cex=0.5) #make-grm source(&quot;~/R/MyLib/manhattan.R&quot;) liCmd=paste0(plink2, &quot; --linear --bfile &quot;, dat, &quot; --pheno &quot;, dat, &quot;.eigenvec --out &quot;, dat) system(liCmd) #plot EigenRes=read.table(paste0(dat, &quot;.assoc.linear&quot;), as.is = T, header = T) EigenRes$Praw=EigenRes$P gc=qchisq(median(EigenRes$P), 1, lower.tail = F)/qchisq(0.5, 1, lower.tail = F) print(paste(&quot;GC = &quot;, format(gc, digits = 4))) ## [1] &quot;GC = 1.692&quot; EigenRes$P=pchisq(qchisq(EigenRes$Praw, 1, lower.tail = F)/gc, 1, lower.tail = F) manhattan(EigenRes, title=&quot;EigenGWAS 1&quot;, pch=16, cex=0.3, bty=&#39;n&#39;) #QQplot chiseq=rchisq(nrow(EigenRes), 1) qqplot(chiseq, qchisq(EigenRes$Praw, 1, lower.tail = F), xlab=expression(paste(&quot;Theoretical &quot;, chi[1]^2)), ylab=expression(paste(&quot;Observed &quot;, chi[1]^2)), bty=&quot;n&quot;, col=&quot;grey&quot;, pch=16, cex=0.5) points(sort(chiseq), sort(qchisq(EigenRes$P, 1, lower.tail = F)), col=&quot;black&quot;, pch=16, cex=0.5) legend(&quot;topleft&quot;, legend = c(&quot;Raw&quot;, &quot;GC correction&quot;), pch=16, cex=0.5, col=c(&quot;grey&quot;, &quot;black&quot;), bty=&#39;n&#39;) abline(a=0, b=1, col=&quot;red&quot;, lty=2) 2.1.2 Rscript pipeline for inbred population plink2=&#39;/Users/gc5k/bin/plink_mac/plink&#39; dat=&quot;./data/arab/arab&quot; #make-grm grmCmd=paste(plink2, &quot;--bfile &quot;, dat, &quot;--make-grm-gz --out &quot;, dat) system(grmCmd) gz=gzfile(paste0(dat, &quot;.grm.gz&quot;)) grm=read.table(gz, as.is = T) Ne=-1/mean(grm[grm[,1]!=grm[,2], 4]/2) Me=1/var(grm[grm[,1]!=grm[,2], 4]/2) print(paste(&quot;Ne=&quot;, format(Ne, digits = 2), &quot;Me=&quot;, format(Me, digits = 2))) ## [1] &quot;Ne= 293 Me= 395&quot; #pca pcaCmd=paste(plink2, &quot;--bfile &quot;, dat, &quot;--pca 5 --out &quot;, dat) system(pcaCmd) barplot(read.table(paste0(dat, &quot;.eigenval&quot;), as.is = T)[,1]/2, border = F) pc=read.table(paste0(dat, &quot;.eigenvec&quot;), as.is = T) plot(pc[,3], pc[,4], xlab=&quot;Eigenvector 1&quot;, ylab=&quot;Eigenvector 2&quot;, bty=&quot;n&quot;, main=&quot;Eigenspace&quot;, bty=&quot;n&quot;, col=ifelse(pc[,3]&gt;0, &quot;red&quot;, &quot;blue&quot;), pch=16, cex=0.5) #make-grm source(&quot;~/R/MyLib/manhattan.R&quot;) liCmd=paste0(plink2, &quot; --linear --bfile &quot;, dat, &quot; --pheno &quot;, dat, &quot;.eigenvec --out &quot;, dat) system(liCmd) #plot EigenRes=read.table(paste0(dat, &quot;.assoc.linear&quot;), as.is = T, header = T) EigenRes$Praw=EigenRes$P gc=qchisq(median(EigenRes$P), 1, lower.tail = F)/qchisq(0.5, 1, lower.tail = F) print(paste(&quot;GC = &quot;, format(gc, digits = 4))) ## [1] &quot;GC = 9.047&quot; EigenRes$P=pchisq(qchisq(EigenRes$Praw, 1, lower.tail = F)/gc, 1, lower.tail = F) manhattan(EigenRes, title=&quot;EigenGWAS 1&quot;, pch=16, cex=0.3, bty=&#39;n&#39;) #QQplot chiseq=rchisq(nrow(EigenRes), 1) qqplot(chiseq, qchisq(EigenRes$Praw, 1, lower.tail = F), xlab=expression(paste(&quot;Theoretical &quot;, chi[1]^2)), ylab=expression(paste(&quot;Observed &quot;, chi[1]^2)), bty=&quot;n&quot;, col=&quot;grey&quot;, pch=16, cex=0.5) points(sort(chiseq), sort(qchisq(EigenRes$P, 1, lower.tail = F)), col=&quot;black&quot;, pch=16, cex=0.5) legend(&quot;topleft&quot;, legend = c(&quot;Raw&quot;, &quot;GC correction&quot;), pch=16, cex=0.5, col=c(&quot;grey&quot;, &quot;black&quot;), bty=&#39;n&#39;) abline(a=0, b=1, col=&quot;red&quot;, lty=2) 2.2 Protocol for predicted eigenvectors The prediction accuracy can be written as \\[R^2 \\approx \\frac{1}{1+\\frac{n_e}{m}}\\] "],
["resequencing-studies.html", "Chapter 3 Resequencing studies 3.1 Technical review 3.2 Drop HWE test", " Chapter 3 Resequencing studies This is a technical review for resequencing studies. 3.1 Technical review 3.1.1 NGS 3.1.2 Chip data 3.1.3 GBS 3.2 Drop HWE test "],
["simulating-population-structure.html", "Chapter 4 Simulating population structure 4.1 Genetic drift 4.2 Three pop 4.3 Six pop 4.4 Wishart distribution simulation 4.5 Distribution of the Wishart diagonal elements 4.6 Homo cohort 4.7 Heterogeneous cohort 4.8 Tracy-Widom distribution", " Chapter 4 Simulating population structure Details 4.1 Genetic drift As each locus follows binomial distribution, the genetic drift can be modelled \\(\\frac{\\sqrt{pq}}{2n_e}\\), in which \\(n_e\\) is the effective population size. 4.2 Three pop 4.3 Six pop 4.4 Wishart distribution simulation 4.5 Distribution of the Wishart diagonal elements 4.6 Homo cohort 4.7 Heterogeneous cohort 4.8 Tracy-Widom distribution "],
["data-analysis.html", "Chapter 5 Data analysis 5.1 On site examples 5.2 Public datahub (NEO)", " Chapter 5 Data analysis 5.1 On site examples 5.1.1 Arabdiopsis 5.1.2 3K rice 5.1.3 ALS 5.1.4 GF 5.1.5 UK birds 5.1.6 Darwin’s finches 5.1.7 GBS Maize 5.1.8 UK Biobank 5.2 Public datahub (NEO) "],
["meta-research.html", "Chapter 6 Meta-research 6.1 \\(n_e\\) 6.2 \\(m_e\\)", " Chapter 6 Meta-research Meta-research 6.1 \\(n_e\\) 6.2 \\(m_e\\) "],
["conclusion.html", "Chapter 7 Conclusion 7.1 Statistical power 7.2 Selection pattern", " Chapter 7 Conclusion 7.1 Statistical power 7.2 Selection pattern "],
["references.html", "References", " References "]
]
